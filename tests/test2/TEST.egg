option auto = true;
option version = 0.0.1;
option k = 2;


inh source : SourceUnit for PROG;
inh tds    : TDS        for BLOC, INST, INSTS, TERME, FACTEUR, TYPE, CHAMPS, TERMES;
syn type   : DTYPE      for TYPE, TERME, FACTEUR;

syn syn_type : DTYPE for FX;
inh her_type : DTYPE for FX;

syn syn_champs : LCHAMPS for CHAMPS;
inh her_champs : LCHAMPS for CHAMPS;

syn syn_types : LTYPES for TERMES;
inh her_types : LTYPES for TERMES;

space  separateur  is    "[\n\r\t ]+" ;
space  comments    is    "\/\/.*[\n\r]" ;
sugar  aco         is    "\{" ;
sugar  acf         is    "\}" ;
sugar  paro        is    "\(" ;
sugar  parf        is    "\)" ;
sugar  pv          is    ";" ;
sugar  aff         is    "=" ;
sugar  struct      is    "struct" ;
sugar  pt          is    "\." ;
sugar  v           is    "," ;
sugar  etoile      is    "\*" ;
sugar  new         is    "new" ;
sugar  type        is    "type" ;
sugar  vrai        is    "true" ;
sugar  faux        is    "false" ;
sugar  si          is    "if" ;
sugar  sinon       is    "else" ;
sugar  print       is    "print" ;
sugar  tantque     is    "while" ;
sugar  int         is    "int" ;
sugar  bool        is    "bool" ;
term   entier      is    "[0-9]+" ;
term   ident       is    "[a-zA-Z_éèàçÉÈÀÇ]+" ;


PROG -> ident #tds BLOC ;
#tds {
    BLOC^tds := null;
}

BLOC -> aco #tds INSTS acf #tds2 ;
global        -- globale aux actions de cette règle
    TDS t;    -- pour voir la TDS du bloc

#tds {
    t := new TDS(BLOC^tds);
    INSTS^tds := t;
}

#tds2 {
    write "TDS:\n" + t;
}

-------------------------------------------------------
-- les types
-------------------------------------------------------
TYPE -> bool #type ;
#type {
    TYPE^type := new DTYPE("booleen", 1);
}

TYPE -> int  #type ;
#type {
    TYPE^type := new DTYPE("entier", 4);
}

-------------------------------------------------------
-- les noms de types
-------------------------------------------------------
TYPE -> ident  #a ;
#a {
    INFO i;
    INFOTYPE it;

    i := TYPE^tds.chercherGlobalement(ident^txt);
    if i = null then
        error(B_undefined_type, ident^txt);
    else
        match i with INFOTYPE then
            it := i;
            TYPE^type := it.getType();
        else
            error(B_not_type, ident^txt);
        end
    end
}

-------------------------------------------------------
-- instructions (et declarations)
-------------------------------------------------------
INSTS -> ;

INSTS -> INST INSTS ;

-----------------------------------------------------------
-- On ajoute le nom du type dans la TDS avec sa definition
-----------------------------------------------------------
INST -> type ident aff TYPE  #tds pv  ;
#tds {
    INFO i;

    i := INST^tds.chercherGlobalement(ident^txt);
    if i /= null then
        error(B_var_already_defined, ident^txt);
    else
        i := new INFOTYPE(TYPE^type);
        INST^tds.inserer(ident^txt, i);
    end
}

-------------------------------------------------------
-- les variables
-------------------------------------------------------
INST -> TYPE ident aff TERME #tdstype pv ;
#tdstype {
    INFO i;
    i := INST^tds.chercherLocalement(ident^txt);
    if i /= null then
        error(B_var_already_defined, ident^txt);
    elseif ~TYPE^type.compareTo(TERME^type) then
        error(B_not_compatible, TYPE^type, TERME^type);
    else
        i := new INFOVAR(TYPE^type);
        INST^tds.inserer(ident^txt,  i);
    end
}

-------------------------------------------------------
-- affectations
-------------------------------------------------------
INST -> ident #a1 FX aff TERME pv #a2 ;
#a1 {
    INFO var;
    var := INST^tds.chercherGlobalement(ident^txt);
    if var = null then
        error(B_undefined_var, ident^txt);
    else
        FX^her_type := var.getType();
    end
}

#a2 {
    DTYPE t;
    t := TERME^type;
    if ! t.compareTo(FX^syn_type) then
        error(B_not_compatible, t, FX^syn_type);
    end
}

-------------------------------------------------------
-- Conditionnelle
-------------------------------------------------------
INST -> si paro TERME #type parf BLOC sinon BLOC ;
#type {
    if ~TERME^type.compareTo(new DTYPE("booleen", 1)) then
        error(B_not_bool, TERME^type);
    end
}

INST -> tantque paro TERME #type parf BLOC ;
#type {
    if ~TERME^type.compareTo(new DTYPE("booleen", 1)) then
        error(B_not_bool, TERME^type);
    end
}

TERME -> FACTEUR #type ;
#type {
    TERME^type := FACTEUR^type;
}

-------------------------------------------------------
-- variable eventuellement qualifiée
-------------------------------------------------------
FACTEUR -> ident #a1 FX #a2 ;
#a1 {
    INFO i;
    i := FACTEUR^tds.chercherGlobalement(ident^txt);
    if i = null then
        error(B_undefined_var, ident^txt);
    else
        FX^her_type := i.getType();
    end
}

#a2 {
    FACTEUR^type := FX^syn_type;
}

-------------------------------------------------------
-- qualificateur
-------------------------------------------------------
FX -> #a ;
#a {
    FX^syn_type := FX^her_type;
}

---------------------------------------------------------------
FX -> etoile #a1 FX #a2 ;
#a1 {
    POINTEUR p;
    match FX^her_type with POINTEUR then
        p := FX^her_type;
        FX1^her_type := p.getType();
    else
        error(B_not_pointeur, FX^her_type);
    end
}

#a2 {
    FX^syn_type := FX1^syn_type;
}

-------------------------------------------------------
-- Constante entiere
-------------------------------------------------------
FACTEUR -> entier #type ;
#type {
    FACTEUR^type := new DTYPE("entier", 4);
}

-------------------------------------------------------
-- constantes booleennes
-------------------------------------------------------
FACTEUR -> vrai #type ;
#type {
    FACTEUR^type := new DTYPE("booleen", 1);
}

FACTEUR -> faux #type ;
#type {
    FACTEUR^type := new DTYPE("booleen", 1);
}

-------------------------------------------------------
FACTEUR -> paro TERME parf #type ;
#type {
    FACTEUR^type := TERME^type;
}

-------------------------------------------------------
-- Les pointeurs
-------------------------------------------------------
TYPE -> etoile TYPE  #a ;
#a {
    TYPE^type := new POINTEUR(TYPE1^type);
}

-------------------------------------------------------
-- init pointeur
-------------------------------------------------------
FACTEUR -> new TYPE paro parf #a ;
#a {
    FACTEUR^type := new POINTEUR(TYPE^type);
}

-------------------------------------------------------
-- pour les structures
-------------------------------------------------------
TYPE -> struct aco #a CHAMPS acf #b ;
#a {
    CHAMPS^her_champs := new LCHAMPS();
}

#b {
    TYPE^type := new STRUCT(CHAMPS^syn_champs);
}

CHAMPS -> #a ;
#a {
    CHAMPS^syn_champs := CHAMPS^her_champs;
}

CHAMPS -> TYPE ident pv #a CHAMPS #b ;
#a {
    if CHAMPS^her_champs.chercher(ident^txt) != null then
        error(B_field_already_defined, ident^txt);
    else
        CHAMPS^her_champs.inserer(new CHAMP(ident^txt, TYPE^type));
    end

    CHAMPS1^her_champs := CHAMPS^her_champs;
}

#b {
    CHAMPS^syn_champs := CHAMPS1^syn_champs;
}

FX -> pt ident #a1 FX #a2 ;
#a1 {
    STRUCT p;
    LCHAMPS liste_champs;
    CHAMP champ;

    match FX^her_type with STRUCT then
        p := FX^her_type;
        liste_champs := p.getChamps();
        champ := liste_champs.chercher(ident^txt);

        if champ = null then
            error(B_undefined_field, ident^txt, p);
        end

        FX1^her_type := champ.getType();
    else
        error(B_not_struct, FX^her_type);
    end
}

#a2 {
    FX^syn_type := FX1^syn_type;
}

FACTEUR -> aco TERME #a1 TERMES #a2 acf ;
#a1 {
    LTYPES l;
    l := new LTYPES();
    l.inserer(TERME^type);
    TERMES^her_types := l;
}

#a2 {
    FACTEUR^type := new TUPLE(TERMES^syn_types);
}

TERMES -> #a ;
#a {
    TERMES^syn_types := TERMES^her_types;
}

TERMES -> v TERME #a1 TERMES #a2 ;
#a1 {
    TERMES^her_types.inserer(TERME^type);
    TERMES1^her_types := TERMES^her_types;
}

#a2 {
    TERMES^syn_types := TERMES1^syn_types;
}
